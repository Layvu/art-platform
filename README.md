## Запуск проекта:

### 1) Установить пакеты, добавить payload клиент

pnpm install

pnpm add -D payload

### 2) Пересоздать БД

psql -U art_user -d postgres -c "DROP DATABASE art_platform;"
psql -U art_user -d postgres -c "CREATE DATABASE art_platform;"

psql -U art_user -d art_platform -c "CREATE EXTENSION IF NOT EXISTS pgcrypto;"

### 3) Минимально наполнить БД

### 4) Выполнить миграцию триггеров (для автоматического обновления зависимых таблиц)

psql -U art_user -d art_platform -f src/migrations/create_author_stats_triggers.sql

### 5) Поднять докер + dev сервер Next + Payload

pnpm dev

### 6) Создание администратора

При первом запуске перейдите на `http://localhost:3000/admin` и создайте первого пользователя (главного администратора),
чтобы получить доступ к панели управления

## Отдельно поднять и потушить БД

docker compose up -d

docker compose down

## Проверить состояние

docker compose ps

## Сгенерировать типы Payload

npx payload generate:types

## Тестирование

### Запускает сценарий проверки уязвимостей:

pnpm test

### Полная проверка перед коммитом/деплоем: линтинг, форматирование, тесты, пробная сборка проекта

pnpm check-app

## URLs:

- frontend: http://localhost:3000
- payload admin: http://localhost:3000/admin
- api: http://localhost:3000/api/products

## Триггеры:

- products_update_count: пересчитывает authors.products_count после операций с products
- products_update_categories: обновляет authors_product_categories с категориями товаров, которые продают авторы

## Shadcn UI:

pnpm dlx shadcn@latest add componentName

## Deployment

### Локальный запуск (Windows PowerShell)

Скрипт собирает проект, генерирует миграции (если есть изменения), архивирует и отправляет на сервер

.\deploy.ps1

### На ВМ

Проект находится в `/var/app/`,
Скрипты управления в `/var/app/scripts/`

**1. Полное пересоздание проекта и БД (Сброс данных):**

bash /var/app/scripts/reset_db.sh

bash /var/app/scripts/update.sh

**2. Стандартное обновление проекта (Код + Миграции):**

Применяет новые миграции (без потери данных) и обновляет код приложения

bash /var/app/scripts/update.sh

**3. Очистка логов и кэша:**

bash /var/app/scripts/clean.sh

## Логика работы API сервисов и кастомных эндпоинтов:

**Клиентские сервисы (Client Services):**
Методы вызываются в UI компонентах. Они отправляют запросы на кастомные эндпоинты (Next.js API Routes) и не требуют в заголовке запроса токена авторизации (аутентификация происходит автоматически через cookies/сессию)

**Серверные сервисы (Server Services):**
Методы вызываются внутри кастомных эндпоинтов. Перед их вызовом эндпоинт проверяет user (его роль, права, существование) - основная сущность пользователя в payloadCMS. Авторизация осуществляется через проверку сессии (Cookies), полученной из заголовков запроса (req.user)

Нам нужны эндпоинты, потому что в Payload имеет доступ к пользовательской сессии только на сервере, а следовательно только в эндпоинте Payload работает с правильными правами доступа

## Заметки

в next js правильный подход такой:

- Каждая папка в app - отдельный роут.
- Если папка в круглых скобках, то новый роут не создаётся - это группирующая папка, которая не влияет на URL, но позволяет создавать внутри неё роуты и применять для них общий layout, loading, error и т.п. к группе страниц
- Если папка в квадратных скобках - значит этот путь является динамическим, значение которого доступно через params в компоненте. Если он лежит в другой папке, то роут складывается из внешней папки и внутренней: папка products, в ней [product] => products/some_product.
- При этом в каждой папке должен быть обязательно page.tsx - это серверный компонент, без него не будет обнаружен роут. Рядом можно создать клиентский файл, тот же Product.tsx где описать клиентскую логику с хуками, указав 'use client'
- Хороший подход - в page.tsx фетчи, работа с бд, логика, в клиентском файле хуки, вёрстка, работа с отображением

Клиентская работа с параметрами заключается в том, чтобы не перезагружать страницу, а отрисовывать на существующей, например, новое модальное окно/фильтр и при это менять параметры роута. В остальном лучше использовать серверные переходы между страницами для SEO и производительности

Dynamic Import Converter for Next.js - для ленивой загрузки компонентов
